;Exercise 1.9: Each of the following two procedures defines a method for adding two positive integers in terms of the procedures inc, which increments its argument by 1, and dec, which decrements its argument by 1.

(define (+ a b)
  (if (= a 0) 
      b 
      (inc (+ (dec a) b))))

(define (+ a b)
  (if (= a 0) 
      b 
      (+ (dec a) (inc b))))
;Using the substitution model, illustrate the process generated by each procedure in evaluating (+ 4 5). Are these processes iterative or recursive?

;for the first process 
(+ 4 5) 
(if (= 4 0) 
	5 
	(inc (+ (dec 4) 5)))

(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc(+ 0 5)))))
(inc (inc (inc (inc(5)))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9

;for the second process 
(+ 4 5)
(if (= 4 0)
	5
	(+ (dec 4) (inc 5)))
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9

; second process is interative, first process is recursive


;Exercise 1.10: The following procedure computes a mathematical function called Ackermann’s function.

(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))
;What are the values of the following expressions?

(A 1 10)
(A 0 (A 1 9))
(A 0 (A 0 (A 1 8)))
(A 0 (A 0 (A 0 (A 1 7))))
;.... nested to (A 1 1) because the conditional will terminate first when y = 1
;(A 1 1) = 2, and (A 0 2) = 2*2 so the answer is 2^10 = 1024

(A 2 4)
(A 1 (A 2 3))
(A 1 (A 1 (A 2 2)))
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 (A 0 (A 1 1))))
(A 1 (A 1 (A 0 2)))
(A 1 (A 1 4))
(A 1 (A 0 (A 1 3)))
(A 1 (A 0 (A 0 (A 1 2))))
(A 1 (A 0 (A 0 4)))
(A 1 (A 0 8))
(A 1 16)
; similar to above (A 1 N) = 2^N so the answer is 2^16=65536

(A 3 3)
(A 2 (A 3 2))
(A 2 (A 2 (A 3 1)))
(A 2 (A 2 2))
(A 2 4)
(A 1 (A 2 3))
(A 1 (A 1 (A 2 2)))
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 4))
(A 1 16)
; 2^16 = 65536

;Consider the following procedures, where A is the procedure defined above:

(define (f n) (A 0 n))
(define (g n) (A 1 n))
(define (h n) (A 2 n))
(define (k n) (* 5 n n))
;Give concise mathematical definitions for the functions computed by the procedures f, g, and h for positive integer values of n. For example, (k n) computes 5n2.

;f for x = 0, 2*n
;g for x = 1, 2^n
;h 
;(A 2 n)
;(A 1 (A 2 n-1))
;(A 1 (A 1 (A 2 n-2)))...until (n-m) = 1 when it will be replaced by 2
;so (A 1 (A 1 (A 1 2))) = 2^(2^(2^2)) and (h n) = 2^2^...^2 n times

;Exercise 1.11: A function f is defined by the rule that f(n)=n if n<3 and f(n)=f(n−1)+2f(n−2)+3f(n−3) if n≥3. Write a procedure that computes f by means of a recursive process. Write a procedure that computes f by means of an iterative process.

;recursive definition
(define (f n)
	(if (< n 3) 
		n
		(+ (f (- n 1))	(* 2 (f (- n 2))) (* 3 (f (- n 3))))))

;iterative definition
;if n = 1, f(1) = 1
;if n = 2, f(2) = 2 
;if n = 3, f(3) = f(2) + 2*f(1) + 3*f(0) = 2+2+0 = 4
;if n = 4, f(4) = f(3) + 2*f(2) + 3*f(1) = 4+(2*2)+(3*1) = 11
;if n = 5, f(5) = f(4) + 2*f(3) + 3*f(2) = 11 + 2*4 + 3*2

(define (f-iter n count f1 f2 f3)
	(if (= count n)
		f1
		(f-iter n (+ count 1) (+ f1 (* 2 f2) (* 3 f3)) f1 f2)))
(define (fnew n)
	(if (< n 3)
		n
		(f-iter n 2 2 1 0)))
;at each stage the iteration keeps track of 4 state variables which are all that is needed to go to the next step.  f1 is replaced by the f(n) definition using the previous 3 f states to genreate the next one.  The solution is built up starting from the first 3 values of f in reverse with f(2), f(1), and f(0) being 2, 1, 0 respectively for the base case of f(3).

;Exercise 1.12: The following pattern of numbers is called Pascal’s triangle.

         1
       1   1
     1   2   1
   1   3   3   1
 1   4   6   4   1
       . . .
;The numbers at the edge of the triangle are all 1, and each number inside the triangle is the sum of the two numbers above it. Write a procedure that computes elements of Pascal’s triangle by means of a recursive process.
(define (pascal r c)
	(cond 	((= c 1) 1)
			((= c r) 1)
			(else (+ (pascal (- r 1) (- c 1)) (pascal (- r 1) c)))))
;computes the element of the triangle specified by r (row) and c (column), so c = 1 is always the first element of the row and c = r is always the last element of the row.  See the following outputs
(pascal 5 1)
;Value: 1
(pascal 5 2)
;Value: 4
(pascal 5 3)
;Value: 6

;Exercise 1.13: Prove that Fib(n) is the closest integer to φn/5⎯⎯√, where φ=(1+5⎯⎯√)/2. Hint: Let ψ=(1−5⎯⎯√)/2. Use induction and the definition of the Fibonacci numbers (see 1.2.2) to prove that Fib(n)=(φn−ψn)/5⎯⎯√.
;φ+ψ=1
;φ-ψ=sqrt(5)
;fib(0) = 0
;fib(1) = 1 = φ+ψ
;fib(n) = fib(n-1) + fib(n-2)
;(φ+ψ)^n = 1
;(φ-ψ)^n = 5^(n/2)
;(a-b)^2 = a^2 - 2ab + b^2
;(a+b)^2 = a^2 + 2ab + b^2
;a^2 + b^2 = (a-b)^2 + (a+b)^2 / 2
;Trying to prove that Fib(n)=(φn−ψn)/5⎯⎯√ 
;Fib(0) = (1 - 1)/sqrt(5) = 0 which holds true
;Assume that Fib(k)=(φk−ψk)/5⎯⎯√ , show that Fib(k+1)=(φk+1−ψk+1)/5⎯⎯√ 
;We know that Fib(k+1) = Fib(k) + Fib(k-1) = (φk−ψk)/5⎯⎯√ + Fib(k-1)
;Also we know that (φk−ψk)/5⎯⎯√ = Fib(k-1) + Fib(k-2), since k is an arbitrary variable, we can rewrite this as (φk+1−ψk+1)/5⎯⎯√ = Fib(k) + Fib(k-1) which matches the definition of Fib(k+1) given by the formula. Since ψ is less than 1, it tends to 0 as n gets large while φ is greater than 1 so the formula will be donimated by the φ term.
